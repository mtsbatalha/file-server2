"""
WebDAV Service (Nginx)
"""

import os
import re
from typing import Dict, Any, Optional, List
import logging

from .base import BaseService, ServiceResult, ServiceStatus


logger = logging.getLogger(__name__)


class WebDAVService(BaseService):
    """
    WebDAV Service implementation using Nginx.
    Provides Web-based Distributed Authoring and Versioning.
    """
    
    @property
    def name(self) -> str:
        return "webdav"
    
    @property
    def display_name(self) -> str:
        return "WebDAV Server (Nginx)"
    
    @property
    def package_name(self) -> str:
        return "nginx"
    
    @property
    def service_name(self) -> str:
        return "nginx"
    
    @property
    def config_path(self) -> str:
        return "/etc/nginx/sites-available/webdav.conf"
    
    @property
    def port(self) -> int:
        return 443
    
    @property
    def default_settings(self) -> Dict[str, Any]:
        return {
            # Server settings
            "listen_port": 80,
            "listen_ssl_port": 443,
            "server_name": "_",
            
            # SSL settings
            "ssl_enabled": True,
            "ssl_cert": "/etc/ssl/certs/webdav.crt",
            "ssl_key": "/etc/ssl/private/webdav.key",
            
            # WebDAV settings
            "dav_methods": ["PUT", "DELETE", "MKCOL", "COPY", "MOVE"],
            "dav_access": "user:rw group:rw all:r",
            "autoindex": True,
            "create_full_put_path": True,
            
            # Authentication
            "auth_basic": True,
            "auth_realm": "WebDAV Restricted",
            "htpasswd_file": "/etc/nginx/.htpasswd",
            
            # Performance
            "client_max_body_size": "0",  # No limit
            "client_body_temp_path": "/tmp/webdav",
            
            # Security
            "deny_methods": [],
            "allow_methods": ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "MKCOL", "COPY", "MOVE", "PROPFIND"],
        }
    
    def configure(self, settings: Dict[str, Any]) -> ServiceResult:
        """Configure WebDAV server"""
        try:
            # Merge with default settings
            config_settings = {**self.default_settings, **settings}
            
            # Build configuration content
            config_lines = [
                "# WebDAV configuration - generated by File Server Manager",
                f"# Generated at: {self._get_timestamp()}",
                ""
            ]
            
            # Server block
            config_lines.append("server {")
            
            # HTTP listener (redirect to HTTPS if SSL enabled)
            config_lines.append(f"    listen {config_settings['listen_port']};")
            config_lines.append(f"    server_name {config_settings['server_name']};")
            
            # SSL configuration
            if config_settings['ssl_enabled']:
                config_lines.append("")
                config_lines.append("    # Redirect HTTP to HTTPS")
                config_lines.append("    return 301 https://$host$request_uri;")
                config_lines.append("}")
                config_lines.append("")
                config_lines.append("server {")
                config_lines.append(f"    listen {config_settings['listen_ssl_port']} ssl;")
                config_lines.append(f"    server_name {config_settings['server_name']};")
                config_lines.append("")
                config_lines.append(f"    ssl_certificate {config_settings['ssl_cert']};")
                config_lines.append(f"    ssl_certificate_key {config_settings['ssl_key']};")
                config_lines.append("    ssl_protocols TLSv1.2 TLSv1.3;")
                config_lines.append("    ssl_prefer_server_ciphers on;")
                config_lines.append("    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;")
            
            # Base WebDAV directory
            base_path = settings.get('base_path', '/var/www/webdav')
            config_lines.append("")
            config_lines.append(f"    root {base_path};")
            
            # Client settings
            config_lines.append(f"    client_max_body_size {config_settings['client_max_body_size']};")
            config_lines.append(f"    client_body_temp_path {config_settings['client_body_temp_path']};")
            
            # Main location
            config_lines.append("")
            config_lines.append("    location / {")
            
            # DAV methods
            dav_methods = " ".join(config_settings['dav_methods'])
            config_lines.append(f"        dav_methods {dav_methods};")
            config_lines.append("        dav_ext_methods PROPFIND OPTIONS;")
            config_lines.append(f"        dav_access {config_settings['dav_access']};")
            
            # Options
            if config_settings['create_full_put_path']:
                config_lines.append("        create_full_put_path on;")
            if config_settings['autoindex']:
                config_lines.append("        autoindex on;")
            
            # Authentication
            if config_settings['auth_basic']:
                config_lines.append(f'        auth_basic "{config_settings["auth_realm"]}";')
                config_lines.append(f"        auth_basic_user_file {config_settings['htpasswd_file']};")
            
            # Access control
            config_lines.append("")
            config_lines.append("        # Allow methods")
            for method in config_settings['allow_methods']:
                config_lines.append(f"        dav_access {method};")
            
            config_lines.append("    }")
            config_lines.append("}")
            
            # Write configuration
            config_content = "\n".join(config_lines)
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            self._write_config(config_content)
            
            # Create necessary directories and files
            self._setup_directories(config_settings)
            
            # Setup SSL certificates if enabled
            if config_settings['ssl_enabled']:
                self._setup_ssl(config_settings)
            
            # Enable site
            self._enable_site()
            
            # Test and reload nginx
            self._test_and_reload()
            
            return ServiceResult(
                success=True,
                message="WebDAV service configured successfully",
                data={"config_path": self.config_path}
            )
            
        except Exception as e:
            logger.error(f"Failed to configure WebDAV: {e}")
            return ServiceResult(
                success=False,
                message="Failed to configure WebDAV service",
                error=str(e)
            )
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.utcnow().isoformat()
    
    def _setup_directories(self, settings: Dict[str, Any]) -> None:
        """Setup necessary directories"""
        # Base WebDAV directory
        base_path = settings.get('base_path', '/var/www/webdav')
        os.makedirs(base_path, exist_ok=True)
        os.chmod(base_path, 0o755)
        
        # Temp directory
        temp_path = settings['client_body_temp_path']
        os.makedirs(temp_path, exist_ok=True)
        os.chmod(temp_path, 0o755)
        
        # Sites-enabled symlink
        sites_enabled = "/etc/nginx/sites-enabled"
        os.makedirs(sites_enabled, exist_ok=True)
    
    def _setup_ssl(self, settings: Dict[str, Any]) -> None:
        """Setup SSL certificates"""
        cert_path = settings['ssl_cert']
        key_path = settings['ssl_key']
        
        if os.path.exists(cert_path) and os.path.exists(key_path):
            return
        
        # Generate self-signed certificate
        cert_dir = os.path.dirname(cert_path)
        key_dir = os.path.dirname(key_path)
        
        os.makedirs(cert_dir, exist_ok=True)
        os.makedirs(key_dir, exist_ok=True)
        
        try:
            self._run_command([
                "openssl", "req", "-x509", "-nodes",
                "-days", "365",
                "-newkey", "rsa:2048",
                "-keyout", key_path,
                "-out", cert_path,
                "-subj", "/C=US/ST=State/L=City/O=Organization/CN=webdav"
            ])
            
            os.chmod(key_path, 0o600)
            os.chmod(cert_path, 0o644)
            
            logger.info("Generated WebDAV SSL certificates")
            
        except Exception as e:
            logger.warning(f"Could not generate SSL certificates: {e}")
    
    def _enable_site(self) -> None:
        """Enable the WebDAV site"""
        enabled_link = "/etc/nginx/sites-enabled/webdav.conf"
        
        if not os.path.exists(enabled_link):
            os.symlink(self.config_path, enabled_link)
    
    def _test_and_reload(self) -> None:
        """Test and reload Nginx configuration"""
        # Test config
        result = self._run_command(["nginx", "-t"], check=False)
        if result.returncode != 0:
            raise Exception(f"Nginx config test failed: {result.stderr}")
        
        # Reload
        self._run_command(["systemctl", "reload", "nginx"])
    
    def get_config(self) -> Dict[str, Any]:
        """Get current WebDAV configuration"""
        config = {}
        
        content = self._read_config()
        if not content:
            return config
        
        # Parse nginx config
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            
            if line.startswith('listen'):
                match = re.match(r'listen\s+(\d+)', line)
                if match:
                    if 'ssl' in line:
                        config['ssl_port'] = int(match.group(1))
                    else:
                        config['listen_port'] = int(match.group(1))
            
            elif line.startswith('server_name'):
                config['server_name'] = line.split()[1].rstrip(';')
            
            elif line.startswith('ssl_certificate '):
                config['ssl_cert'] = line.split()[1].rstrip(';')
            
            elif line.startswith('ssl_certificate_key'):
                config['ssl_key'] = line.split()[1].rstrip(';')
            
            elif line.startswith('root'):
                config['base_path'] = line.split()[1].rstrip(';')
            
            elif line.startswith('dav_methods'):
                methods = line.replace('dav_methods', '').replace(';', '').strip()
                config['dav_methods'] = methods.split()
        
        return config
    
    def create_location(
        self,
        path: str,
        alias: str,
        auth_required: bool = True,
        methods: List[str] = None,
        writable: bool = True
    ) -> ServiceResult:
        """Create a new WebDAV location"""
        try:
            # Read existing config
            content = self._read_config()
            if not content:
                return ServiceResult(
                    success=False,
                    message="Configuration not found"
                )
            
            # Create directory
            os.makedirs(alias, exist_ok=True)
            os.chmod(alias, 0o755)
            
            # Build location block
            location_block = [
                "",
                f"    location {path} {{",
                f"        alias {alias};",
            ]
            
            if writable:
                default_methods = ["PUT", "DELETE", "MKCOL", "COPY", "MOVE"]
                dav_methods = " ".join(methods or default_methods)
                location_block.append(f"        dav_methods {dav_methods};")
            
            location_block.append("        dav_ext_methods PROPFIND OPTIONS;")
            location_block.append("        dav_access user:rw group:rw all:r;")
            location_block.append("        create_full_put_path on;")
            location_block.append("        autoindex on;")
            
            if auth_required:
                location_block.append('        auth_basic "WebDAV";')
                location_block.append("        auth_basic_user_file /etc/nginx/.htpasswd;")
            
            location_block.append("    }")
            
            # Find position to insert (before the last closing brace)
            lines = content.split('\n')
            insert_pos = len(lines) - 1
            
            for i, line in enumerate(lines):
                if line.strip() == '}' and i > len(lines) - 5:
                    insert_pos = i
                    break
            
            # Insert location block
            lines = lines[:insert_pos] + location_block + lines[insert_pos:]
            
            # Write updated config
            self._write_config("\n".join(lines))
            
            # Test and reload
            self._test_and_reload()
            
            logger.info(f"Created WebDAV location: {path}")
            
            return ServiceResult(
                success=True,
                message=f"Created WebDAV location: {path}",
                data={"path": path, "alias": alias}
            )
            
        except Exception as e:
            logger.error(f"Failed to create WebDAV location: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to create WebDAV location: {path}",
                error=str(e)
            )
    
    def create_user(self, username: str, password: str) -> ServiceResult:
        """Create a WebDAV user (htpasswd)"""
        try:
            htpasswd_file = "/etc/nginx/.htpasswd"
            
            # Check if file exists
            if not os.path.exists(htpasswd_file):
                # Create new htpasswd file
                self._run_command([
                    "htpasswd", "-cb", htpasswd_file, username, password
                ])
            else:
                # Update existing user or add new
                self._run_command([
                    "htpasswd", "-b", htpasswd_file, username, password
                ])
            
            logger.info(f"Created WebDAV user: {username}")
            
            return ServiceResult(
                success=True,
                message=f"Created WebDAV user: {username}",
                data={"username": username}
            )
            
        except Exception as e:
            logger.error(f"Failed to create WebDAV user: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to create WebDAV user: {username}",
                error=str(e)
            )
    
    def delete_user(self, username: str) -> ServiceResult:
        """Delete a WebDAV user"""
        try:
            htpasswd_file = "/etc/nginx/.htpasswd"
            
            if not os.path.exists(htpasswd_file):
                return ServiceResult(
                    success=False,
                    message="htpasswd file not found"
                )
            
            self._run_command(["htpasswd", "-D", htpasswd_file, username])
            
            logger.info(f"Deleted WebDAV user: {username}")
            
            return ServiceResult(
                success=True,
                message=f"Deleted WebDAV user: {username}"
            )
            
        except Exception as e:
            logger.error(f"Failed to delete WebDAV user: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to delete WebDAV user: {username}",
                error=str(e)
            )
    
    def list_users(self) -> List[str]:
        """List WebDAV users"""
        users = []
        htpasswd_file = "/etc/nginx/.htpasswd"
        
        if not os.path.exists(htpasswd_file):
            return users
        
        try:
            with open(htpasswd_file, 'r') as f:
                for line in f:
                    if ':' in line:
                        users.append(line.split(':')[0])
        
        except Exception as e:
            logger.error(f"Failed to list WebDAV users: {e}")
        
        return users
    
    def get_connections(self) -> List[Dict[str, Any]]:
        """Get current WebDAV connections"""
        connections = []
        
        try:
            result = self._run_command(["ss", "-tn", f"sport = :{self.default_settings['listen_port']}"])
            
            for line in result.stdout.split('\n')[1:]:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 5:
                        connections.append({
                            "local_addr": parts[3],
                            "remote_addr": parts[4],
                            "state": parts[0] if parts else "unknown"
                        })
            
            # Also check SSL port
            result = self._run_command(["ss", "-tn", f"sport = :{self.default_settings['listen_ssl_port']}"])
            
            for line in result.stdout.split('\n')[1:]:
                if line.strip():
                    parts = line.split()
                    if len(parts) >= 5:
                        connections.append({
                            "local_addr": parts[3],
                            "remote_addr": parts[4],
                            "state": parts[0] if parts else "unknown"
                        })
        
        except Exception as e:
            logger.error(f"Failed to get WebDAV connections: {e}")
        
        return connections
    
    def get_info(self) -> Dict[str, Any]:
        """Get comprehensive WebDAV service information"""
        info = super().get_info()
        
        config = self.get_config()
        
        info.update({
            "ssl_enabled": config.get('ssl_cert') is not None,
            "listen_port": config.get('listen_port', 80),
            "ssl_port": config.get('ssl_port', 443),
            "base_path": config.get('base_path', '/var/www/webdav'),
            "dav_methods": config.get('dav_methods', []),
            "users": self.list_users() if self.is_installed() else [],
            "connections": self.get_connections() if self.get_status() == ServiceStatus.RUNNING else []
        })
        
        return info