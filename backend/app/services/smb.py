"""
SMB/CIFS Service (Samba)
"""

import os
import re
from typing import Dict, Any, Optional, List
import logging

from .base import BaseService, ServiceResult, ServiceStatus


logger = logging.getLogger(__name__)


class SMBService(BaseService):
    """
    SMB/CIFS Service implementation using Samba.
    Provides Windows-compatible file sharing.
    """
    
    @property
    def name(self) -> str:
        return "smb"
    
    @property
    def display_name(self) -> str:
        return "SMB/CIFS Server (Samba)"
    
    @property
    def package_name(self) -> str:
        return "samba"
    
    @property
    def service_name(self) -> str:
        return "smbd"
    
    @property
    def config_path(self) -> str:
        return "/etc/samba/smb.conf"
    
    @property
    def port(self) -> int:
        return 445
    
    @property
    def default_settings(self) -> Dict[str, Any]:
        return {
            # Global settings
            "workgroup": "WORKGROUP",
            "server_string": "File Server",
            "server_role": "standalone",
            
            # Network
            "interfaces": "lo eth0",
            "bind_interfaces_only": True,
            
            # Authentication
            "security": "user",
            "map_to_guest": "Bad User",
            "guest_account": "nobody",
            "encrypt_passwords": True,
            "passdb_backend": "tdbsam",
            
            # Protocol settings
            "min_protocol": "SMB3",
            "max_protocol": "SMB3",
            "client_min_protocol": "SMB3",
            "client_max_protocol": "SMB3",
            
            # Security
            "null_passwords": False,
            "obey_pam_restrictions": True,
            "pam_password_change": True,
            "unix_password_sync": True,
            
            # Logging
            "log_file": "/var/log/samba/log.%m",
            "max_log_size": 50,
            "log_level": 1,
            "syslog": 1,
            
            # Performance
            "socket_options": "TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192",
            "deadtime": 15,
            "keepalive": 300,
            
            # File settings
            "create_mask": "0644",
            "directory_mask": "0755",
            "force_create_mode": "0644",
            "force_directory_mode": "0755",
            
            # VFS modules
            "vfs_objects": "acl_xattr",
            "map_acl_inherit": True,
            "store_dos_attributes": True,
            
            # Domain/AD settings (optional)
            "realm": None,
            "password_server": None,
            "idmap_config": None,
        }
    
    def configure(self, settings: Dict[str, Any]) -> ServiceResult:
        """Configure Samba server"""
        try:
            # Merge with default settings
            config_settings = {**self.default_settings, **settings}
            
            # Build configuration content
            config_lines = [
                "# Samba configuration - generated by File Server Manager",
                f"# Generated at: {self._get_timestamp()}",
                ""
            ]
            
            # [global] section
            config_lines.append("[global]")
            config_lines.append(f"    workgroup = {config_settings['workgroup']}")
            config_lines.append(f"    server string = {config_settings['server_string']}")
            config_lines.append(f"    server role = {config_settings.get('server_role', 'standalone')}")
            
            # Network
            config_lines.append(f"    interfaces = {config_settings['interfaces']}")
            config_lines.append(f"    bind interfaces only = {'yes' if config_settings['bind_interfaces_only'] else 'no'}")
            
            # Authentication
            config_lines.append(f"    security = {config_settings['security']}")
            config_lines.append(f"    map to guest = {config_settings['map_to_guest']}")
            config_lines.append(f"    guest account = {config_settings['guest_account']}")
            config_lines.append(f"    encrypt passwords = {'yes' if config_settings['encrypt_passwords'] else 'no'}")
            config_lines.append(f"    passdb backend = {config_settings['passdb_backend']}")
            
            # Protocol
            config_lines.append(f"    server min protocol = {config_settings['min_protocol']}")
            config_lines.append(f"    server max protocol = {config_settings['max_protocol']}")
            config_lines.append(f"    client min protocol = {config_settings['client_min_protocol']}")
            config_lines.append(f"    client max protocol = {config_settings['client_max_protocol']}")
            
            # Logging
            config_lines.append(f"    log file = {config_settings['log_file']}")
            config_lines.append(f"    max log size = {config_settings['max_log_size']}")
            config_lines.append(f"    log level = {config_settings['log_level']}")
            
            # Security
            config_lines.append(f"    null passwords = {'yes' if config_settings['null_passwords'] else 'no'}")
            config_lines.append(f"    obey pam restrictions = {'yes' if config_settings['obey_pam_restrictions'] else 'no'}")
            
            # Performance
            config_lines.append(f"    socket options = {config_settings['socket_options']}")
            config_lines.append(f"    deadtime = {config_settings['deadtime']}")
            
            # VFS
            config_lines.append(f"    vfs objects = {config_settings['vfs_objects']}")
            
            # File settings
            config_lines.append(f"    create mask = {config_settings['create_mask']}")
            config_lines.append(f"    directory mask = {config_settings['directory_mask']}")
            
            # Homes section
            config_lines.append("")
            config_lines.append("[homes]")
            config_lines.append("    comment = Home Directories")
            config_lines.append("    browseable = no")
            config_lines.append("    writable = yes")
            config_lines.append("    create mask = 0700")
            config_lines.append("    directory mask = 0700")
            config_lines.append("    valid users = %S")
            
            # Printers (disabled)
            config_lines.append("")
            config_lines.append("[printers]")
            config_lines.append("    comment = All Printers")
            config_lines.append("    path = /var/spool/samba")
            config_lines.append("    browseable = no")
            config_lines.append("    guest ok = no")
            config_lines.append("    writable = no")
            config_lines.append("    printable = yes")
            
            # Write configuration
            config_content = "\n".join(config_lines)
            self._write_config(config_content)
            
            # Create necessary directories
            self._create_directories(config_settings)
            
            # Restart service if running
            if self.get_status() == ServiceStatus.RUNNING:
                self.restart()
            
            return ServiceResult(
                success=True,
                message="SMB service configured successfully",
                data={"config_path": self.config_path}
            )
            
        except Exception as e:
            logger.error(f"Failed to configure SMB: {e}")
            return ServiceResult(
                success=False,
                message="Failed to configure SMB service",
                error=str(e)
            )
    
    def _get_timestamp(self) -> str:
        from datetime import datetime
        return datetime.utcnow().isoformat()
    
    def _create_directories(self, settings: Dict[str, Any]) -> None:
        """Create necessary directories"""
        log_dir = "/var/log/samba"
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
            os.chmod(log_dir, 0o755)
    
    def get_config(self) -> Dict[str, Any]:
        """Get current Samba configuration"""
        config = {"global": {}, "shares": {}}
        
        content = self._read_config()
        if not content:
            return config
        
        current_section = None
        
        for line in content.split('\n'):
            line = line.strip()
            if not line or line.startswith('#') or line.startswith(';'):
                continue
            
            # Check for section header
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1].lower()
                if current_section not in ['global', 'homes', 'printers']:
                    config["shares"][current_section] = {}
                continue
            
            if current_section and '=' in line:
                parts = line.split('=', 1)
                if len(parts) == 2:
                    key = parts[0].strip().lower().replace(' ', '_')
                    value = parts[1].strip()
                    
                    if current_section in ['global', 'homes', 'printers']:
                        config["global"][key] = value
                    elif current_section in config["shares"]:
                        config["shares"][current_section][key] = value
        
        return config
    
    def create_share(
        self,
        name: str,
        path: str,
        comment: str = "",
        browseable: bool = True,
        writable: bool = True,
        guest_ok: bool = False,
        valid_users: List[str] = None,
        create_mask: str = "0644",
        directory_mask: str = "0755"
    ) -> ServiceResult:
        """Create a new SMB share"""
        try:
            # Validate share name
            if not name or not re.match(r'^[a-zA-Z0-9_-]+$', name):
                return ServiceResult(
                    success=False,
                    message="Invalid share name"
                )
            
            # Create directory if it doesn't exist
            if not os.path.exists(path):
                os.makedirs(path)
                os.chmod(path, 0o755)
            
            # Read existing config
            content = self._read_config() or ""
            
            # Check if share already exists
            if f"[{name}]" in content:
                return ServiceResult(
                    success=False,
                    message=f"Share '{name}' already exists"
                )
            
            # Build share configuration
            share_config = [
                "",
                f"[{name}]",
                f"    comment = {comment or name}",
                f"    path = {path}",
                f"    browseable = {'yes' if browseable else 'no'}",
                f"    writable = {'yes' if writable else 'no'}",
                f"    guest ok = {'yes' if guest_ok else 'no'}",
                f"    create mask = {create_mask}",
                f"    directory mask = {directory_mask}",
            ]
            
            if valid_users:
                share_config.append(f"    valid users = {', '.join(valid_users)}")
            
            # Append share to config
            content += "\n".join(share_config)
            self._write_config(content)
            
            # Reload Samba
            self._run_command(["smbcontrol", "all", "reload-config"], check=False)
            
            logger.info(f"Created SMB share: {name}")
            
            return ServiceResult(
                success=True,
                message=f"Created SMB share: {name}",
                data={"name": name, "path": path}
            )
            
        except Exception as e:
            logger.error(f"Failed to create SMB share: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to create SMB share: {name}",
                error=str(e)
            )
    
    def delete_share(self, name: str) -> ServiceResult:
        """Delete an SMB share"""
        try:
            content = self._read_config()
            if not content:
                return ServiceResult(
                    success=False,
                    message="Configuration file not found"
                )
            
            # Find and remove share section
            lines = content.split('\n')
            new_lines = []
            in_share = False
            
            for line in lines:
                if line.strip() == f"[{name}]":
                    in_share = True
                    continue
                
                if in_share:
                    if line.strip().startswith('['):
                        in_share = False
                        new_lines.append(line)
                else:
                    new_lines.append(line)
            
            if in_share or f"[{name}]" not in content:
                return ServiceResult(
                    success=False,
                    message=f"Share '{name}' not found"
                )
            
            # Write updated config
            self._write_config("\n".join(new_lines))
            
            # Reload Samba
            self._run_command(["smbcontrol", "all", "reload-config"], check=False)
            
            logger.info(f"Deleted SMB share: {name}")
            
            return ServiceResult(
                success=True,
                message=f"Deleted SMB share: {name}"
            )
            
        except Exception as e:
            logger.error(f"Failed to delete SMB share: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to delete SMB share: {name}",
                error=str(e)
            )
    
    def list_shares(self) -> List[Dict[str, Any]]:
        """List all SMB shares"""
        shares = []
        config = self.get_config()
        
        for share_name, share_config in config.get("shares", {}).items():
            shares.append({
                "name": share_name,
                "path": share_config.get("path", ""),
                "comment": share_config.get("comment", ""),
                "browseable": share_config.get("browseable", "no") == "yes",
                "writable": share_config.get("writable", "no") == "yes",
                "guest_ok": share_config.get("guest_ok", "no") == "yes"
            })
        
        return shares
    
    def create_user(self, username: str, password: str) -> ServiceResult:
        """Create a Samba user (must exist as system user)"""
        try:
            # Check if system user exists
            result = self._run_command(["id", username], check=False)
            if result.returncode != 0:
                return ServiceResult(
                    success=False,
                    message=f"System user '{username}' does not exist"
                )
            
            # Add Samba password
            self._run_command(
                ["smbpasswd", "-a", "-n", username],
                input_text=f"{password}\n{password}\n"
            )
            
            # Enable user
            self._run_command(["smbpasswd", "-e", username], check=False)
            
            logger.info(f"Created SMB user: {username}")
            
            return ServiceResult(
                success=True,
                message=f"Created SMB user: {username}",
                data={"username": username}
            )
            
        except Exception as e:
            logger.error(f"Failed to create SMB user: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to create SMB user: {username}",
                error=str(e)
            )
    
    def delete_user(self, username: str) -> ServiceResult:
        """Delete a Samba user"""
        try:
            self._run_command(["smbpasswd", "-x", username])
            
            logger.info(f"Deleted SMB user: {username}")
            
            return ServiceResult(
                success=True,
                message=f"Deleted SMB user: {username}"
            )
            
        except Exception as e:
            logger.error(f"Failed to delete SMB user: {e}")
            return ServiceResult(
                success=False,
                message=f"Failed to delete SMB user: {username}",
                error=str(e)
            )
    
    def list_users(self) -> List[str]:
        """List Samba users"""
        users = []
        
        try:
            result = self._run_command(["pdbedit", "-L"], check=False)
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    if ':' in line:
                        username = line.split(':')[0]
                        users.append(username)
        
        except Exception as e:
            logger.error(f"Failed to list SMB users: {e}")
        
        return users
    
    def get_connections(self) -> List[Dict[str, Any]]:
        """Get current SMB connections"""
        connections = []
        
        try:
            result = self._run_command(["smbstatus", "-b"], check=False)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                for line in lines[3:]:  # Skip header
                    if line.strip():
                        parts = line.split()
                        if len(parts) >= 4:
                            connections.append({
                                "pid": parts[0],
                                "user": parts[1],
                                "group": parts[2],
                                "machine": parts[3] if len(parts) > 3 else "",
                            })
        
        except Exception as e:
            logger.error(f"Failed to get SMB connections: {e}")
        
        return connections
    
    def test_config(self) -> Dict[str, Any]:
        """Test Samba configuration"""
        result = {
            "valid": True,
            "errors": [],
            "warnings": [],
            "output": ""
        }
        
        try:
            test_result = self._run_command(["testparm", "-s"], check=False)
            result["output"] = test_result.stdout
            
            if test_result.returncode != 0:
                result["valid"] = False
                result["errors"].append(test_result.stderr)
            
        except Exception as e:
            result["valid"] = False
            result["errors"].append(str(e))
        
        return result
    
    def get_info(self) -> Dict[str, Any]:
        """Get comprehensive SMB service information"""
        info = super().get_info()
        
        config = self.get_config()
        global_config = config.get("global", {})
        
        info.update({
            "workgroup": global_config.get("workgroup", "WORKGROUP"),
            "server_string": global_config.get("server_string", ""),
            "min_protocol": global_config.get("server_min_protocol", "SMB3"),
            "security_mode": global_config.get("security", "user"),
            "shares": self.list_shares() if self.is_installed() else [],
            "users": self.list_users() if self.is_installed() else [],
            "connections": self.get_connections() if self.get_status() == ServiceStatus.RUNNING else [],
            "config_test": self.test_config() if self.is_installed() else None
        })
        
        return info